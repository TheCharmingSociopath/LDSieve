#include <string.h>
#include <limits.h>
#include <iomanip>
#include <fstream>


#include <NTL/quad_float.h>
#include <NTL/mat_ZZ.h>
#include <NTL/mat_RR.h>
#include <NTL/LLL.h>
#include "LinAlg.h"
#include "Lattice.h"


#define PI 3.1415926

			   
void gen_rand_lattice(mat_ZZ& B,long dims){
  long i;
  //long dims = atoi(argv[1]);
  long temp = 4; // Drawn with a fair dice  //time(NULL);
  srand(temp);
  SetSeed(to_ZZ(temp));
  ZZ max;
  GenPrime(max, 10 * dims);
  //mat_ZZ B;
  B.SetDims(dims,dims);
  for(i = 1;i < dims; i++){
    B[i][i] = 1;
    B[i][0] = RandomBnd(max);
  }
  B[0][0] = max;
}



// Babai, reducing point x represented in B*, and giving lattice point res in B
long* Babai_Bstar_To_B(t_BaseGS* base, double *x){
  int i,j;
  long n = base->dim;
  long* res = new long[n];
  for(i=n-1;i>=0;i--){
    res[i] = floor(x[i]+.5);
    for(j=0;j<i;j++){
      x[j]-=res[i]*(base->mu)[n*i+j];
    }
  }
  return res;
}

double tau=5;

long discrete_gaussian(double t,double sigma2){
  long x,tt = floor(t+.5);
  double p,r,dt = t-tt;
  long B = floor(tau*sqrt(sigma2))+1;
  while(1){
    x = ((long) rand()) % (2*B+1);
    x -= B;
    p = exp(-((x-dt)*(x-dt)) / (2*sigma2));
    r = ((int) rand() % 100000) / 100000;
    if (r<p) return x+tt;
  }
}


void spherical_sampling(int n,double *res){
  int i,j;
  for(i=n-1;i>=0;i--){
    res[i] = (float) discrete_gaussian(0,1000000);
  }
  float sqn = square_norm(n,res);
  for(i=n-1;i>=0;i--)
    res[i]/= sqrt(sqn);

}

void gaussian_sampling(t_BaseGS* base,double *x,long *res,double sigma){
  int i,j;
  long n = base->dim;
  for(i=n-1;i>=0;i--)
    x[i]=0; 

  for(i=n-1;i>=0;i--){
    res[i] = discrete_gaussian(x[i],sigma*sigma/base->r[i]);
    for(j=0;j<i;j++){
      x[j]-=res[i]*(base->mu)[n*i+j];
    }
  }
}


double* Canon_To_Bstar(t_BaseGS* base, double* x){
  int i,j, n = base->dim;
  double* res = new double[n];
  for(i=0;i<n;i++){
    res[i]=0;
    for(j=0;j<n;j++)
      res[i] += x[j]*(base->Bstar)[n*i+j];
  }
  
  for(i=0;i<n;i++)
    res[i] /= (base->r)[i];

  return res;
}

long* B_To_Canon(t_BaseGS* base, long* x){
  long n = base->dim;
  // cerr << "dimension " << n << "B[0] :" ;
  //cerr_vec(n,base->B);

  long * res = new long[n];
  IntMatVecProd(n,base->B, x,res);
  return res;
}


void B_To_Canon(t_BaseGS* base,long* res,long* x){
  long n = base->dim;
  // cerr << "dimension " << n << "B[0] :" ;
  //cerr_vec(n,base->B);

  IntMatVecProd(n,base->B, x,res);
}

double* Bstar_To_Canon(t_BaseGS* base, double* x){
  long n = base->dim;
  double * res = new double[n];
  MatVecProd(n,base->Bstar, x,res);
  return res;
}

double* B_To_Bstar(t_BaseGS* base, long* x){
  long n = base->dim;
  double * res = new double[n];
  MatVecProd(n,base->mu, x,res);
  return res;
}

// x :MUST  be in the lattice generated by B
long* Canon_To_B(t_BaseGS* base, long* x){
  long n = base->dim;
  double* resf = new double[n];
  long* res = new long[n], *verif;
  MatVecProd(n,base->Binv, x,resf);
  for(int i=0;i<n;i++)
    res[i] = (long) floor(resf[i] + 0.5);
  verif = B_To_Canon(base, res);
  for(int i=0;i<n;i++){
    if (verif[i]!=x[i]){
      cerr << "Error in Canon_to_B : target point is not in the Lattice" << endl;
    }
  }
  delete resf,verif;
  return res;
}

t_BaseGS* new_BaseGS(mat_ZZ B_ZZ){
  mat_RR B_RR,Binv_RR,mu_RR,Bstar_RR,muinv_RR;
  vec_RR r_RR;
  RR det;
  int n=B_ZZ.NumCols();

  cerr << "LLL reduction ... ";
  LLL_XD(B_ZZ,0.99);
  cerr << " Done " << endl;

  cerr << "Computing Gram Schmidt decompostion ... ";
  ComputeGS(B_ZZ,mu_RR,r_RR);
  cerr << " Done ";

  for (int i=1;i<=n;i++)
    mu_RR(i,i)=1;
  inv(det,muinv_RR,mu_RR);

  conv_mat(B_RR,B_ZZ);
  Bstar_RR = muinv_RR* B_RR;

  inv(det,Binv_RR,B_RR);


  if (det==0)
    cerr << "Error in new_BaseGS : The Basis is not invertible" << endl;
  
  // cerr << B_ZZ << endl << mu_RR << endl << r_RR<< endl;

  t_BaseGS* res = new t_BaseGS;
  res->Bstar = To_mat_double(Bstar_RR);
  res->dim = B_ZZ.NumCols();
  res->muinv = To_mat_double(muinv_RR);
  res->B =  To_mat_long(B_ZZ);
  res->Binv = To_mat_double(Binv_RR);
  res->mu = To_mat_double(mu_RR);
  res->r = To_vec_double(r_RR);

  return res;
}

t_BaseGS* randomized_BaseGS(mat_ZZ B_ZZ){
  mat_ZZ B_new,T;
  int n =  B_ZZ.NumCols(),i,j;
  T.SetDims(n,n);

  for(i=1;i<=n;i++){
    for(j=i+1;j<=n;j++)
      T(i,j) = (rand() % 9) -4; 
    T(i,i)=1;
  }
  B_new= T*B_ZZ;
  return new_BaseGS(B_new);
}


float lambda1_GH(t_BaseGS* base, int b,int e){
  int n = e-b;
  float lam1 = sqrt(2*PI*n);
  for (int i = b; i < e; ++i){
    lam1 *= pow(base->r[i], 1 / (2.0*(float) n) );
  }
  return lam1;
}


float Ball_Count_GH(t_BaseGS* base, int b,int e, float R){
  int n = e-b;
  float Vr = R * sqrt(2*PI*exp(1) / ((float) n) );
  float C = 1;
  for (int i = b; i < e; ++i){
    //cerr << Vr << "# " << C << " ";
    C*=Vr;
    C/= sqrt(base->r[i]);
  }
  //cerr << C << endl <<endl;

  return C;
}
